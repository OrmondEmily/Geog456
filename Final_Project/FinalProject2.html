<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
crossorigin=""/>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
crossorigin=""></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<!-- Minimap -->
<link rel="stylesheet" href="./minimap/Control.MiniMap.min.css" />
<script src="./minimap/Control.MiniMap.min.js" type="text/javascript"></script>


<!--fonts-->
<link href="https://fonts.googleapis.com/css2?family=Prompt:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Prompt:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">

<script src="./data/County1980FINAL.js"></script>
<script src="./data/County1989FINAL.js"></script>
<script src="./data/County2000Redo.js"></script>
<script src="./data/County2010USE.js"></script>
<script src="./data/County2020.js"></script>
<script src="./data/unitedstates.js"></script>
<script src="./data/BlackTownPoints.js"></script>
<script src="./data/FINALSTATE.js"></script>

<style>
    body {
        background-color: rgb(171, 193, 212);
    }

    h3 {
        font-family: 'Poppins', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
        text-align: center;
        color: #17252d
    }

    h2 {
        font-family: "Prompt", Haettenschweiler, 'Arial Narrow Bold', sans-serif; 
        color: rgb(214, 241, 255);
    }
    
    h4 {font-family: 'Poppins', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
       color:aliceblue
    }

    .definitionStyle{
        color: #04151f;
    }

    #mapContainer {
        position: relative;
        display: inline-block;
        width: 800px; 
        height: 600px;
    }

    #buttonContainer {
        position: absolute;
        top: 270px; 
        left: 10px;
    }

    #mapi {
        height: 500px; 
        width: 675px;
        left: 23%
    }  
      
    .buttonStyle{
        padding: 20px 45px;
        font-size: 30px;
        margin: 4px 2px;
        width: 165px;
        border-radius: 10px;
        font-family: "Prompt", Haettenschweiler, 'Arial Narrow Bold', sans-serif; 
        background-color: #457898; 
        border: none;
        display: block;
        color: rgb(214, 241, 255);  
    }

    .buttonStyleClicked{
        padding: 20px 45px;
        font-size: 30px;
        margin: 4px 2px;
        width: 165px;
        border-radius: 10px;
        font-family: "Prompt", Haettenschweiler, 'Arial Narrow Bold', sans-serif; 
        background-color: #04151f; 
        border: none;
        display: block;
        color: rgb(214, 241, 255);  
    }

    #title{
        font-size: 50px;
        font-family: 'Prompt', Haettenschweiler, 'Arial Narrow Bold', sans-serif;
        text-align: center;
        color: #152b3b;
    }

    #notesContainer {
        position: absolute;
        top: 250px; /* Adjust this value as needed */
        right: 5%;
        width: 25%;
        padding: 20px;
        background-color:#457898;
        border-radius: 10px;
        z-index: 1000;
    }      
</style>

<body>
    <h1 id = 'title'>Black Town Demographics by County</h1>
    <h3>Each polygon represents a county containing a Black Town. One way a Black Town can be found is by looking at small cities (populations less than 50,000) and a Black population of 90% or more. Hover over each county to learn more abou the Black Town within that county or click the buttons to see how the population demographics have changed over time.</h3>
    <div id = "mapContainer"> 
        <div id="mapi"></div>
    </div>
    <div id = "buttonContainer">
    <button id="button1980" class="buttonStyle" onclick="toggleButton(this); updateStateStyle(1980), myFunction(county1980, 1980);">1980</button> <!--add a new function fot state to change the style -->
    <button id="button1989" class="buttonStyle" onclick="toggleButton(this); updateStateStyle(1989), myFunction(county1989, 1989);">1989</button>
    <button id="button2000" class="buttonStyle" onclick="toggleButton(this); updateStateStyle(2000), myFunction(county2000, 2000);">2000</button>
    <button id="button2010" class="buttonStyle" onclick="toggleButton(this); updateStateStyle(2010), myFunction(county2010, 2010);">2010</button>
    <button id="button2020" class="buttonStyle" onclick="toggleButton(this); updateStateStyle(2020), myFunction(county2020, 2020);">2020</button>

    </div>
    <div id = 'notesContainer'>
        <h2>Notes</h2>
        <h4>Years 1980 and 1989 were derived from the Intercensal County Estimates by Age, Sex, Race which was then manipulated in R to represent 
            county population percentages. <br> <br> Black Towns can be defined by a Tradition definition or an Expansive Definition. <br><span class ="definitionStyle">Traditional:</span>
            A municipality founded by and for Black people, with the intent of autonomy and self-governance. Seeking and/or securing incorporation status 
            under state or other local authorities.<br><span class ="definitionStyle">Expansive: </span>Any majority-Black or all-Black communities with well-defined areas/boundaries 
            that were started by Black people, regardless of intent to seek incorporation status
        </h4>
        <h2>Sources</h2>
        <h4><a href="https://github.com/PublicaMundi/MappingAPI/blob/master/data/geojson/us-states.json">US GeoJSON Background</a></h4>
        <h4><a href="https://www.census.gov/data/tables/time-series/demo/popest/1980s-county.html">1980-1989 Intercensal Data</a></h4>
        <h4><a href="https://www.census.gov/ ">2000-2020 Census Data</a></h4>
        <h4>Black Town Data and definitions Courtesy of Adrienne Hall and <a href ='https://carolinacartography.org/black-town-map/'>Carolina Cartography Collective</a></h4>
    </div>
    
    <script>
        var map = L.map('mapi').setView([40.00, -95], 3.5);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
	    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
	    subdomains: 'abcd',
	    maxZoom: 20
        }).addTo(map);
        

        function updateStateStyle(year) {
    if (stateLayer !== undefined) {
        map.removeLayer(stateLayer); // Remove the existing state layer if it exists
    }

    var stateLayer;
    switch (year) {
        case 1980:
            stateLayer = L.geoJSON(stateData, {
                style: function(feature) {
                    var propertyName = "StateDATAFINAL_x1980blackprct";
                    return {
                        fillColor: getColor(feature.properties[propertyName]),
                        weight: .25,
                        opacity: 1,
                        color: 'black',
                        fillOpacity: 1
                    };
                },
                onEachFeature: function(feature, layer) {
                    layer.on('click', function(e) {
                        var stateName = feature.properties.NAME; // Get the state name
                        var statePercentage = parseFloat(feature.properties.StateDATAFINAL_x1980blackprct).toFixed(2); // Get the percentage
                        var popupContent = stateName + "<br><b>Percentage:</b> " + statePercentage + "%";
                    layer.bindPopup(popupContent); // Bind popup to the state polygon;
                    });
                }
            });
            break;
        case 1989:
            stateLayer = L.geoJSON(stateData, {
                style: function(feature) {
                    var propertyName = "StateDATAFINAL_x1989blackprct";
                    return {
                        fillColor: getColor(feature.properties[propertyName]),
                        weight: .25,
                        opacity: 1,
                        color: 'black',
                        fillOpacity: 1
                    };
                },onEachFeature: function(feature, layer) {
                    layer.on('click', function(e) {
                        var stateName = feature.properties.NAME; // Get the state name
                        var statePercentage = parseFloat(feature.properties.StateDATAFINAL_x1989blackprct).toFixed(2); // Get the percentage
                        var popupContent = stateName + "<br><b>Percentage:</b> " + statePercentage + "%";
                    layer.bindPopup(popupContent); // Bind popup to the state polygon;
                    });
                }
            });
            break;
        case 2000:
            stateLayer = L.geoJSON(stateData, {
                style: function(feature) {
                    var propertyName = "StateDATAFINAL_x2000blackprct";
                    return {
                        fillColor: getColor(feature.properties[propertyName]),
                        weight: .25,
                        opacity: 1,
                        color: 'black',
                        fillOpacity: 1
                    };
                },onEachFeature: function(feature, layer) {
                    layer.on('click', function(e) {
                        var stateName = feature.properties.NAME; // Get the state name
                        var statePercentage = parseFloat(feature.properties.StateDATAFINAL_x2000blackprct).toFixed(2); // Get the percentage
                        var popupContent = stateName + "<br><b>Percentage:</b> " + statePercentage + "%";
                    layer.bindPopup(popupContent); // Bind popup to the state polygon;
                    });
                }
            });
            break;
        case 2010:
            stateLayer = L.geoJSON(stateData, {
                style: function(feature) {
                    var propertyName = "StateDATAFINAL_x2010blackprct";
                    return {
                        fillColor: getColor(feature.properties[propertyName]),
                        weight: .25,
                        opacity: 1,
                        color: 'black',
                        fillOpacity: 1
                    };
                },onEachFeature: function(feature, layer) {
                    layer.on('click', function(e) {
                        var stateName = feature.properties.NAME; // Get the state name
                        var statePercentage = parseFloat(feature.properties.StateDATAFINAL_x2010blackprct).toFixed(2); // Get the percentage
                        var popupContent = stateName + "<br><b>Percentage:</b> " + statePercentage + "%";
                    layer.bindPopup(popupContent); // Bind popup to the state polygon;
                    });
                }
            });
            break;
        case 2020:
            stateLayer = L.geoJSON(stateData, {
                style: function(feature) {
                    var propertyName = "StateDATAFINAL_x2020blackprct";
                    return {
                        fillColor: getColor(feature.properties[propertyName]),
                        weight: .25,
                        opacity: 1,
                        color: 'black',
                        fillOpacity: 1
                    };
                },onEachFeature: function(feature, layer) {
                    layer.on('click', function(e) {
                        var stateName = feature.properties.NAME; // Get the state name
                        var statePercentage = parseFloat(feature.properties.StateDATAFINAL_x2020blackprct).toFixed(2); // Get the percentage
                        var popupContent = stateName + "<br><b>Percentage:</b> " + statePercentage + "%";
                    layer.bindPopup(popupContent); // Bind popup to the state polygon;
                    });
                }
            });
            break;
        default:
            console.error("Invalid year provided");
            return;
    }

    
    stateTest = stateLayer; // Update the reference to the state layer
    stateLayer.addTo(map);

}



        var osm2 = new L.TileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
	    { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        centerFixed: [63, -150],
		zoomLevelFixed: 2});
    
        var layerGroup = new L.layerGroup([osm2,])

        // var miniMap = new L.Control.MiniMap(layerGroup,
        //  {centerFixed: [19.694154544139877, -155.58880132574754],   // change this to be askala and hawaii
        //     zoomLevelFixed: 6,
        //     height: 150,
        //     width: 150,
        //     aimingRectOptions: {color: 'transparent'},
        //     position:'bottomleft',
        //     }).addTo(map);
    var myHawaiiOptions = {centerFixed: [62.14300408073222, -145.81896265002598],   // change this to be askala and hawaii
            zoomLevelFixed: 2,
            height: 150,
            width: 150,
            aimingRectOptions: {color: 'transparent'},
            position:'bottomleft',
            };
            // Reference to the existing minimap control
var miniMapControl = L.control.minimap(layerGroup, myHawaiiOptions).addTo(map);

// Function to change the layers of the minimap
function changeMinimapLayers(layer) {
    // Remove the existing minimap control from the map
    map.removeControl(miniMapControl);
    var newLayerGroup = new L.LayerGroup([layer, osm2]);
    // Create a new minimap control with the new layer group
    miniMapControl = L.control.minimap(newLayerGroup, myHawaiiOptions).addTo(map);
}

// Example usage:
// var newLayerGroup = new L.LayerGroup([newLayer1, newLayer2]);
// changeMinimapLayers(newLayerGroup);

    


        // Chat gpt helped me with the button 
        function toggleButton(button) {
        var buttons = document.getElementsByClassName("buttonStyle");
        for (var i = 0; i < buttons.length; i++) {
        buttons[i].classList.remove("buttonStyleClicked");
        }

        button.classList.add("buttonStyleClicked");
        }
        var currentLayer = null;
        var alaskaCurrentLayer = null;

    function myFunction(geoJSONlayer, year) {
    if (currentLayer !== null) {
        map.removeLayer(currentLayer);
    }
    currentLayer = L.geoJSON(geoJSONlayer, {
        style: function(feature) {
            var propertyName = getPropertyByYear(year);
            return {
                fillColor: getColor(feature.properties[propertyName]),
                weight: .25,
                opacity: 1,
                color: 'black',
                fillOpacity: 1
            };
        },
        onEachFeature: function(feature, layer) {
            var propertyName = getPropertyByYear(year);
            var blackPopulationPercentage = feature.properties[propertyName];
            var stateName = feature.properties.State_2;
            var COUNTY = feature.properties.NAME; // Modified variable name
            var townName = feature.properties.Town_Name;

            window.COUNTYMap = {};

            // This is for which towns are on in the county an makes sure the county naem doesnt pop up again wen clicked (chat gpt helped)
            var key = stateName + "_" + COUNTY; 
            if (!window.COUNTYMap) { 
                window.COUNTYMap = {};
            }

            // If state-county pair exists, append town name to the existing one
            if (window.COUNTYMap.hasOwnProperty(key)) { 
                window.COUNTYMap[key].townNames.push(townName);
            } else {
                window.COUNTYMap[key] = {
                    percentage: blackPopulationPercentage,
                    townNames: [townName]
                };
            }

            // popup content
            var popupContent = '<b>' + COUNTY + ' County, ' + stateName + '</b><br>' + 
                'Black Towns: ' + window.COUNTYMap[key].townNames.join(', ') +
                '<br> Black Population ' + parseFloat(blackPopulationPercentage).toFixed(2) + '%';

            
            layer.bindPopup(popupContent);

               

        }
    })
    currentLayer.addTo(map)

    if (alaskaCurrentLayer !== null) {
        map.removeLayer(alaskaCurrentLayer);
    }
    alaskaCurrentLayer = L.geoJSON(geoJSONlayer, {
        style: function(feature) {
            var propertyName = getPropertyByYear(year);
            return {
                fillColor: getColor(feature.properties[propertyName]),
                weight: .25,
                opacity: 1,
                color: 'black',
                fillOpacity: 1
            };
        },
        onEachFeature: function(feature, layer) {
            var propertyName = getPropertyByYear(year);
            var blackPopulationPercentage = feature.properties[propertyName];
            var stateName = feature.properties.State_2;
            var COUNTY = feature.properties.NAME; // Modified variable name
            var townName = feature.properties.Town_Name;

            window.COUNTYMap = {};

            // This is for which towns are on in the county an makes sure the county naem doesnt pop up again wen clicked (chat gpt helped)
            var key = stateName + "_" + COUNTY; 
            if (!window.COUNTYMap) { 
                window.COUNTYMap = {};
            }

            // If state-county pair exists, append town name to the existing one
            if (window.COUNTYMap.hasOwnProperty(key)) { 
                window.COUNTYMap[key].townNames.push(townName);
            } else {
                window.COUNTYMap[key] = {
                    percentage: blackPopulationPercentage,
                    townNames: [townName]
                };
            }

            // popup content
            var popupContent = '<b>' + COUNTY + ' County, ' + stateName + '</b><br>' + 
                'Black Towns: ' + window.COUNTYMap[key].townNames.join(', ') +
                '<br> Black Population ' + parseFloat(blackPopulationPercentage).toFixed(2) + '%';

            
            layer.bindPopup(popupContent);

               

        }
    })
    changeMinimapLayers(alaskaCurrentLayer)
}




// Chat gpt and leaflet helped me make the legend
    var legendColors = ['#e66101','#fdb863','#ededed','#b2abd2','#5e3c99'];
    var percentages = [ '0-6%', '6%-13%', '13% (US Average)', '13-56%', '56-100%'];

    var legend = L.control({position: 'bottomright'});

    legend.onAdd = function (map) {
    var div = L.DomUtil.create('div', 'info legend');
    div.innerHTML += '<h5>Black Population <br>Percentage</h5>';
    for (var i = 0; i < legendColors.length; i++) {
        div.innerHTML +=
            '<i style="background:' + legendColors[i] + '"></i> ' +
            percentages[i] + '<br>';
    }
    return div;
    };

    // Add legend to the map
    legend.addTo(map);

    var legendStyle = document.createElement('style');
    legendStyle.innerHTML = '.info.legend { background: white; padding: 5px; border-radius: 5px; }' +
                        '.info.legend i { display: inline-block; width: 15px; height: 15px; margin-right: 6px; }';
    document.getElementsByTagName('head')[0].appendChild(legendStyle);

    // used chat gpt to help me wth this part
        function getPropertyByYear(year) {
        switch (year) {
            case 1980:
                return 'BlackPopulationByCounty1980USETHIS_BlackPrct';
            case 1989:
                return 'BlackPopulationByCounty1989USETHIS_BlackPrct';
            case 2000:
                return '2000CountiesWBlackTownsWPrct_black_prct';
            case 2010:
                return 'Redo2010CountiesWBlackPrct_black_prct';
            case 2020:
                return '2020CountiesWBlackPrct_black_prct';
        }
        }

    // colors from color brewer! and tutorial from leaflet

        function getColor(d) {
        return d > 56  ? '#5e3c99' :
            d > 13  ?  '#b2abd2':
            d === 13  ? '#ededed' : // Make this a darker grey easier to read
            d > 6   ? '#fdb863' :
            d > 0   ?  '#e66101':
            'white';
        }

    var yesTowns = L.layerGroup();
    var noTowns = L.layerGroup();
    var unsureTowns = L.layerGroup();

    // Define circle options for existing, non-existing, and unsure towns
    var existingCircleOptions = {
    color: 'black', // Color for existing towns
    fillColor: 'black',
    fillOpacity: 1,
    radius: 8000 // Adjust the radius of the circle as needed
    };

    var nonExistingCircleOptions = {
    color: 'black', // Outline color for non-existing towns
    fillColor: 'transparent', // Transparent fill color
    fillOpacity: 0, // No fill opacity
    radius: 8000, // Adjust the radius of the circle as needed
    weight: .7
    };

    var unsureCircleOptions = {
    color: 'black', // Color for unsure towns
    fillColor: 'grey',
    fillOpacity: 1,
    radius: 8000,
    weight: 1 
    };

    daPoints.features.forEach(function(feature) {
    var existing = feature.properties.Existing;
    var coordinates = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]];
    var townName = feature.properties.Town_Name;
    var yearEstablished = feature.properties.Year_Established;
    var incorporatedStatus = feature.properties.Incorporated
    var yearIncorporated = feature.properties.Year_Incorporated

    var circleOptions;
    if (existing === "Yes") {
        circleOptions = existingCircleOptions;
    } else if (existing === "No") {
        circleOptions = nonExistingCircleOptions;
    } else if (existing === "Unsure") {
        circleOptions = unsureCircleOptions;
    }
    
    var insidePopup = '<b> Town: ' + townName + '</b><br>' +
                  'Year Established: ' + yearEstablished + '<br>' +
                  'Existing: ' + existing + '<br>' +
                  (incorporatedStatus === "Yes" ? 'Incorporated in ' + yearIncorporated : 'Not Incorporated');

    var circle = L.circle(coordinates, circleOptions).bindPopup(insidePopup);

   
    if (existing === "Yes") {
        circle.addTo(yesTowns);
    } else if (existing === "No") {
        circle.addTo(noTowns);
    } else if (existing === "Unsure") {
        circle.addTo(unsureTowns);
    }
    });

    var townPoints = {
    "Existing Black Towns": yesTowns,
    "Non-Existing Black Towns": noTowns,
    "Unsure of Existence Black Towns": unsureTowns,
    };

    var layerControl = L.control.layers(null, townPoints).addTo(map);

    layerControl.addTo(map);

    
</script>


</body>
</html>